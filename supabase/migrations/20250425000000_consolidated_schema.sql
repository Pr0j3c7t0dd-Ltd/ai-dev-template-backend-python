-- Consolidated schema migration-- This migration contains the complete database schema as of April 23, 2025-- It replaces all previous migrations for a clean setup-- First drop all existing tables and functions to ensure a clean stateDROP FUNCTION IF EXISTS public.check_user_exists(uuid) CASCADE;DROP FUNCTION IF EXISTS public.ensure_user_settings() CASCADE;DROP FUNCTION IF EXISTS public.handle_created_at() CASCADE;DROP FUNCTION IF EXISTS public.handle_updated_at() CASCADE;DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;DROP TABLE IF EXISTS public.user_settings CASCADE;-- Reset database to a clean state-- Create timestamp handling functionsCREATE OR REPLACE FUNCTION public.handle_created_at()RETURNS TRIGGER AS $$BEGIN    NEW.created_at = now();    RETURN NEW;END;$$ LANGUAGE plpgsql;CREATE OR REPLACE FUNCTION public.handle_updated_at()RETURNS TRIGGER AS $$BEGIN    NEW.updated_at = now();    RETURN NEW;END;$$ LANGUAGE plpgsql;-- Create user creation handler functionCREATE OR REPLACE FUNCTION public.handle_new_user()RETURNS TRIGGER AS $$BEGIN    -- Insert the user settings record with explicit defaults    INSERT INTO public.user_settings (        id,        theme,        language,        timezone    )    VALUES (        NEW.id,        'light',        'en',        'UTC'    )    ON CONFLICT (id) DO NOTHING;    RETURN NEW;END;$$ LANGUAGE plpgsql SECURITY DEFINER;-- Add comments to explain functionsCOMMENT ON FUNCTION public.handle_created_at IS'Automatically sets the created_at timestamp to current time for new records.';COMMENT ON FUNCTION public.handle_updated_at IS'Automatically updates the updated_at timestamp to current time when records are modified.';COMMENT ON FUNCTION public.handle_new_user IS'Automatically creates user settings when a new user signs up via Supabase Auth. Uses SECURITY DEFINER to bypass RLS safely.';-- Now recreate everything in the correct orderCREATE TABLE IF NOT EXISTS public.user_settings (    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,    theme TEXT DEFAULT 'light',    language TEXT DEFAULT 'en',    timezone TEXT DEFAULT 'UTC',    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),    updated_at TIMESTAMPTZ NOT NULL DEFAULT now());-- Enable Row Level SecurityALTER TABLE public.user_settings ENABLE ROW LEVEL SECURITY;-- Create the check_user_exists functionCREATE OR REPLACE FUNCTION public.check_user_exists(user_id_param UUID)RETURNS JSONB SECURITY DEFINER AS $$DECLARE    user_exists BOOLEAN;BEGIN    -- Check if the user exists in auth.users    SELECT EXISTS(        SELECT 1 FROM auth.users WHERE id = user_id_param    ) INTO user_exists;    -- Return the result as a JSONB object    RETURN jsonb_build_object('exists', user_exists);END;$$ LANGUAGE plpgsql;-- Set proper permissionsREVOKE ALL ON FUNCTION public.check_user_exists(UUID) FROM PUBLIC;GRANT EXECUTE ON FUNCTION public.check_user_exists(UUID) TO authenticated;-- Add function documentationCOMMENT ON FUNCTION public.check_user_exists IS'Checks if a user with the given UUID exists in the auth.users table.Returns a JSONB object with an "exists" boolean field.This function is used by the application to validate user existence before creating settings.Only authenticated users can execute this function.';-- Create the ensure_user_settings functionCREATE OR REPLACE FUNCTION public.ensure_user_settings()RETURNS JSONB SECURITY DEFINER AS $$DECLARE    user_id UUID;    settings_record JSONB;    user_exists BOOLEAN;BEGIN    -- Get the current user id    user_id := auth.uid();    -- Ensure this function can only be run by authenticated users    IF user_id IS NULL THEN        RAISE EXCEPTION 'Not authenticated';    END IF;    -- Check if the user exists in auth.users    SELECT EXISTS(        SELECT 1 FROM auth.users WHERE id = user_id    ) INTO user_exists;    -- If user doesn't exist, raise a clear error    IF NOT user_exists THEN        RAISE EXCEPTION 'User ID % does not exist in auth.users table', user_id;    END IF;    -- Create user_settings entry if it doesn't exist    INSERT INTO public.user_settings (        id,        theme,        language,        timezone    )    VALUES (        user_id,        'light',        'en',        'UTC'    )    ON CONFLICT (id) DO NOTHING;    -- Return the settings for convenience    SELECT jsonb_build_object(        'id', id,        'theme', theme,        'language', language,        'timezone', timezone    ) INTO settings_record    FROM public.user_settings    WHERE id = user_id;    RETURN settings_record;END;$$ LANGUAGE plpgsql;-- Set permissions for ensure_user_settingsREVOKE ALL ON FUNCTION public.ensure_user_settings() FROM PUBLIC;GRANT EXECUTE ON FUNCTION public.ensure_user_settings() TO authenticated;-- Set permissions for handle_new_user functionREVOKE ALL ON FUNCTION public.handle_new_user() FROM PUBLIC;GRANT EXECUTE ON FUNCTION public.handle_new_user() TO supabase_auth_admin;-- Add function documentationCOMMENT ON FUNCTION public.ensure_user_settings IS'Creates user settings for the current user if they don''t exist and returns the settings.Checks if the user exists in auth.users before attempting to create settings.Call this after authentication if needed.';-- Grant necessary table permissionsGRANT SELECT, INSERT, UPDATE ON TABLE public.user_settings TO authenticated;GRANT ALL ON TABLE public.user_settings TO supabase_auth_admin;-- Create RLS policies-- 1. SELECT policy - Allow users to view their own settingsCREATE POLICY "Users can view only their own settings"    ON public.user_settings    FOR SELECT    TO authenticated    USING (auth.uid() = id);-- 2. INSERT policy - Allow users to insert their own settingsCREATE POLICY "Users can insert their own settings"    ON public.user_settings    FOR INSERT    TO authenticated    WITH CHECK (auth.uid() = id);-- 3. UPDATE policy - Allow users to update their own settingsCREATE POLICY "Users can update only their own settings"    ON public.user_settings    FOR UPDATE    TO authenticated    USING (auth.uid() = id);-- 4. Admin policies - full access for service_roleCREATE POLICY "Service role can manage any user settings"    ON public.user_settings    FOR ALL    TO service_role    USING (true);-- 5. Auth admin policy - access for auth adminCREATE POLICY "Auth admin can manage user settings"    ON public.user_settings    FOR ALL    TO supabase_auth_admin    USING (true);-- 6. Postgres role policy - needed for triggersCREATE POLICY "Postgres role can manage user settings"    ON public.user_settings    FOR ALL    TO postgres    USING (true);-- Set up timestamp triggersCREATE TRIGGER set_user_settings_created_atBEFORE INSERT ON public.user_settingsFOR EACH ROWEXECUTE FUNCTION public.handle_created_at();CREATE TRIGGER set_user_settings_updated_atBEFORE UPDATE ON public.user_settingsFOR EACH ROWEXECUTE FUNCTION public.handle_updated_at();-- Set up user creation triggerCREATE TRIGGER on_auth_user_createdAFTER INSERT ON auth.usersFOR EACH ROWEXECUTE FUNCTION public.handle_new_user();-- Add comprehensive comment for clarityCOMMENT ON TABLE public.user_settings IS'User settings table that extends auth.users with application-specific settings.This table has RLS enabled with policies to ensure:1. Users can only view their own settings2. Users can only update their own settings3. The handle_new_user trigger function can create settings for new users4. Service roles and admin roles can manage any record';
